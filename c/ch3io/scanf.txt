标准输入指键盘   标准输出指屏幕


scanf函数是  头文件<stdio.h>  中的函数,则使用scanf 必须头部包含 语句  #include<stdio.h>



scanf函数第一个参数是<格式字符串>,其中的<占位符>和后面的<变量地址>一一对应

scanf给变量输入值,对目标变量输入必须取目标变量地址  &[取地址符]
为什么scanf使用的是变量地址,因为scanf传入地址,使地址  <指向> 用户输入的值
scanf的第二个变量为目标变量的地址(如果变量为指针变量则取指针变量的地址)


scanf的 功能 与 技巧:


scanf处理数值占位符时,会自动过滤空白字符  (  空白字符包括空格,制表符,换行符  )  
所以<空白字符>既可以用来区分数值输入区间,同时数据之前有多个空白字符(包括回车键)也会被过滤


scanf处理用户输入的原理是:
用户的输入会放到一个缓存区,等到按下回车键后,按照占位符对缓存进行解读
注 : 这个缓存区只有当  [缓存读完]  或者  [程序结束]  时才会关闭/***scanf理解的重难点***/
每次解读用户输入时,会从上一次解读遗留的字符开始,直到读完缓存或者遇到第一个不符合[条件]的字符为止
注  :  条件: (即占位符规定条件)
遇到不符合的条件字符停止时,同时以该字符为下一次第一个解读的字符,不会直接跳过

scanf函数的返回类型是一个整型,  表示  <成功>  读取的  <变量>  个数
如果没有读取任何选项前发生匹配失败,则返回零    (相当于成功读取了零个)
如果在成功读取任何数据之前,发生读取错误或者读取到文件末尾,则返回常量EOF------end of file缩写,用于文件结束标志
EOF默认值  -1    返回EOF的最重要一点就是没有读到任何数据[之前]发生上述错误
scanf的返回值很有用,在处理OJ测试时的多组输入很有用  (online judge)----在线判题

scanf的占位符基本和printf一致
常用如下:
%c	字符
%d   整数
%f	float类型浮点数
%lf  double类型浮点数
%Lf  long double类型浮点数
%s	字符串
%[]	在方括号中指定一组匹配的字符,(比如%[0-9]),遇到不在集合之中的字符匹配就会停止
%[]  的常用组合  :%[a-z]     表示只读取小写字母
				%[A-Z]     表示只读取大写字母
				%[0-9]     只读取数字
				%[a-zA-Z]  求取字母大小写不限 
				%[^a-z]    读取除小写字母以外的其他字母
小总结:
(1) []之间可以之间放想输入的字符,或者按照ascii顺序放入字符集合,无论是字符和字符,字符和字符集合,字符集合和字符集合之间
可以之间链接不用任何符号(比如:%[a-zA-Z] , %[zyxwvutsrqponmlkjihgfedcba]都可行)
(2)上面所有字符,除了%c外,都会自动忽略开头一个或者多个空白字符(空格 指标和回车),%c不忽略空白字符,总是返回当前第一个字符 
如果要强制跳过输入前的空白字符,可以使用scanf(" %c")的形式,即在%c前加一个空格,就可以跳过零个或 [多个] 空白字符
(3) 占位符%s不能简单的等同于字符串,因为它的规则是从当前第一个非空白字符开始读,直到遇到空白
字符(空格 制表符 回车)为止,有这个特性知%s不适和且不能读包含空白字符的字符串
另外,scanf使用%s时候会在字符串变量加一个'\0'字符
(4)scanf将字符串读入数组的时候,不会计算,所以储存字符串可能超出数组的边界,导致不安全的结果,为防止这种情况,应该指定
字符串的最长长度,即写成%[m]s形式,其中[m]是一个整数,表示读取字符串的[最大长度],其他部分都被抛弃
和printf函数占位符  %[m]   d/f  用法不同,其一是printf函数输出为整数或者小数,scanf是用于处理字符串
其二为printf限制输出最小长度,scanf为限制输入最大长度;更详情请看printf篇

赋值忽略符
scanf可以指定输入格式(比如scanf("%d-%d-%d") 就指定了数据<[只]>能以 2024-3-12 的形式输入,
但是当用户输入2024/3/12时,就会提示输入失败)
为了避免这种情况,scanf提供赋值忽略符  *  号,只要把 * 号加在任何占位符的百分号后面,该占位符不会返回值,解析后
被抛弃
例如 :  %d%*c%d%*c%d   %*c表示这个占位符没有对应变量,解读后不必返回,仅作为区别符
这个特点对于输出数字数据时有很好的机制保证程序的健壮性


计算机默认浮点型是double类型,通过在末尾添加字符"f"使得变为float类型,这是强制转换的一种形式


小知识点:因为计算机二进制储存和储存单位有限原因,计算机可能会无法精确保存小数